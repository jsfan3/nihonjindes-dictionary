name: Italian translations only

on:
  pull_request:
    branches: ["main"]

permissions:
  contents: read

jobs:
  guard:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Enforce PR touches only it_words_<something>.json + meta (no deletions, no .gz, pretty JSON, meta updated)
        shell: bash
        run: |
          set -euo pipefail

          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"

          echo "Base: $BASE_SHA"
          echo "Head: $HEAD_SHA"

          ITCOMMON_META="data/lang/it_common/meta.json"

          # Regole:
          # - Consenti SOLO:
          #     * data/lang/it_common/meta.json
          #     * data/lang/it_common/lang/it_words_<qualcosa>.json   (NOT it_words.json)
          # - Vietate SEMPRE le cancellazioni
          # - Vietati SEMPRE file compressi (.json.gz / .jsonl.gz)
          # - JSON deve essere pretty-printed
          ALLOWED_RE='^data/lang/it_common/(meta\.json|lang/it_words_[^/]+\.json)$'
          IT_WORDS_RE='^data/lang/it_common/lang/it_words_[^/]+\.json$'
          FORBIDDEN_COMPRESSED_RE='^data/lang/it_common/lang/it_words_[^/]+\.jsonl?\.gz$'

          is_allowed() {
            local f="$1"
            [[ "$f" =~ $ALLOWED_RE ]]
          }

          is_forbidden_compressed() {
            local f="$1"
            [[ "$f" =~ $FORBIDDEN_COMPRESSED_RE ]]
          }

          check_pretty_json() {
            local f="$1"
            if [ ! -f "$f" ]; then
              echo "::error file=$f::Expected file to exist for pretty-print validation."
              FAIL=1
              return
            fi
            local lines
            lines="$(wc -l < "$f" | tr -d ' ')"
            if [ "${lines:-0}" -le 10 ]; then
              echo "::error file=$f::JSON must be pretty printed (not a single line)."
              FAIL=1
            fi
          }

          FAIL=0
          NEEDS_META=0
          META_TOUCHED=0
          CHANGED_COUNT=0
          declare -a CHANGED_PRETTY=()

          # Hard rule: nessun file compresso tracciato nel repo (sotto it_common/lang)
          FOUND_COMPRESSED="$(
            git ls-files -z -- 'data/lang/it_common/lang/' \
              | tr '\0' '\n' \
              | grep -E "$FORBIDDEN_COMPRESSED_RE" \
              || true
          )"
          if [ -n "$FOUND_COMPRESSED" ]; then
            echo "::error::Compressed Italian translation files are forbidden. Remove these tracked files:"
            echo "$FOUND_COMPRESSED"
            FAIL=1
          fi

          # name-status robusto (null-delimited)
          while IFS= read -r -d '' status; do
            if [[ "$status" =~ ^R|^C ]]; then
              IFS= read -r -d '' old_path
              IFS= read -r -d '' new_path

              CHANGED_COUNT=$((CHANGED_COUNT + 1))
              CHANGED_PRETTY+=("$status $old_path -> $new_path")

              # In questo workflow, una rename/copy Ã¨ consentita solo se entrambe le path sono consentite
              if ! is_allowed "$old_path"; then
                echo "::error file=$old_path::Only these files may be changed: data/lang/it_common/lang/it_words_<something>.json and data/lang/it_common/meta.json."
                FAIL=1
              fi
              if ! is_allowed "$new_path"; then
                echo "::error file=$new_path::Only these files may be changed: data/lang/it_common/lang/it_words_<something>.json and data/lang/it_common/meta.json."
                FAIL=1
              fi

              if is_forbidden_compressed "$new_path"; then
                echo "::error file=$new_path::Compressed Italian translation files (.json.gz/.jsonl.gz) are forbidden."
                FAIL=1
              fi

              if [[ "$new_path" == *.json ]]; then
                check_pretty_json "$new_path"
              fi

              if [[ "$new_path" == "$ITCOMMON_META" ]]; then
                META_TOUCHED=1
              fi
              if [[ "$new_path" =~ $IT_WORDS_RE ]]; then
                NEEDS_META=1
              fi

            else
              IFS= read -r -d '' path

              CHANGED_COUNT=$((CHANGED_COUNT + 1))
              CHANGED_PRETTY+=("$status $path")

              # Cancellazioni sempre vietate
              if [[ "$status" == "D" ]]; then
                echo "::error file=$path::Deletions are forbidden in this workflow."
                FAIL=1
                continue
              fi

              if ! is_allowed "$path"; then
                echo "::error file=$path::Only these files may be changed: data/lang/it_common/lang/it_words_<something>.json and data/lang/it_common/meta.json."
                FAIL=1
                continue
              fi

              if is_forbidden_compressed "$path"; then
                echo "::error file=$path::Compressed Italian translation files (.json.gz/.jsonl.gz) are forbidden."
                FAIL=1
              fi

              # Pretty print check per file presenti in HEAD (A/M ecc.)
              if [[ "$path" == *.json ]]; then
                check_pretty_json "$path"
              fi

              if [[ "$path" == "$ITCOMMON_META" ]]; then
                META_TOUCHED=1
              fi
              if [[ "$path" =~ $IT_WORDS_RE ]]; then
                NEEDS_META=1
              fi
            fi
          done < <(git diff --name-status -z "$BASE_SHA" "$HEAD_SHA" || true)

          if [ "$CHANGED_COUNT" -eq 0 ]; then
            echo "No changed files detected."
            exit 0
          fi

          echo "Changed files (name-status):"
          printf ' - %s\n' "${CHANGED_PRETTY[@]}"

          # Se viene toccato qualsiasi it_words_<something>.json (A/M/R/C),
          # allora meta.json deve essere toccato nello stesso PR.
          if [ "$NEEDS_META" -eq 1 ] && [ "$META_TOUCHED" -eq 0 ]; then
            echo "::error file=$ITCOMMON_META::Any change to data/lang/it_common/lang/it_words_<something>.json requires updating meta.json in the same PR."
            FAIL=1
          fi

          exit $FAIL
